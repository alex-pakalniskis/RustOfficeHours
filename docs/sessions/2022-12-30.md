# 2022-12-30
Save subgraph query result to a CSV file

<br>
<br>

**This week's query**
* https://api.thegraph.com/subgraphs/name/graphprotocol/graph-network-mainnet

``` gql
query GnosisSubgraphs {
  subgraphDeployments(where: {network: "gnosis"}) {
    id
    activeSubgraphCount
    createdAt
    ipfsHash
    subgraphCount
    stakedTokens
    signalledTokens
    originalName
  }
}
```

<br>
<br>

**Let's jump into some code**

From your terminal/command line, create a new `cargo` project and open it with VSCode

``` bash
cargo new gnosis_subgraphs
cd gnosis_subgraphs
code .
```
<br>
<br>

With VSCode now open, update `Cargo.toml` with the following dependencies (add this below `[dependencies]`) then save your changes

``` toml
serde = { version = "1.0.149", features = ["derive"] }
reqwest = { version = "0.11", features =  ["json"]}
tokio = { version = "1.23.0", features = ["full"] }
csv = "1.1.6"
```
<br>
<br>

Open `src/main.rs` in VSCode, delete the `main` function, and add the following `use` statements at the top of the file

``` rust
use std::collections::HashMap;
use std::string::String;
use std::error::Error;
use serde::{Serialize, Deserialize};
```
<br>
<br>

Still in `src/main.rs`, add the following `const` statments below the `use` statements 

``` rust
const NETWORK_SUBGRAPH_URL: &str = "https://api.thegraph.com/subgraphs/name/graphprotocol/graph-network-mainnet";
const NETWORK_SUBGRAPH_QUERY: &str = "{subgraphDeployments(where: {network: \"gnosis\"}) {id activeSubgraphCount createdAt ipfsHash subgraphCount stakedTokens signalledTokens originalName}}";
const CSV_FILE_PATH: &str = "./gnosis_subgraphs.csv";
```
<br>
<br>

Next add some `struct` statements to `src/main.rs` to serialize and deserialize the query results

``` rust
#[allow(non_snake_case)]
#[derive(Debug, Serialize)]
struct CsvRecord<'a> {
    id: &'a String,
    activeSubgraphCount: &'a i32,
    createdAt: &'a i32,
    ipfsHash: &'a String,
    subgraphCount: &'a i32,
    stakedTokens: &'a String,
    signalledTokens: &'a String,
    originalName: &'a Option<String>,
}


#[derive(Debug, Deserialize, PartialEq)]
struct SubgraphDeploymentsResponse {
    data: HashMap<String, Vec<SubgraphDeployment>>
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, PartialEq)]
struct SubgraphDeployment {
    id: String,
    activeSubgraphCount: i32,
    createdAt: i32,
    ipfsHash: String,
    subgraphCount: i32,
    stakedTokens: String,
    signalledTokens: String,
    originalName: Option<String>,
}
```

<br>
<br>

Finally add a `main` function to `src/main.rs`

``` rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let mut map = HashMap::new();
    map.insert("query", NETWORK_SUBGRAPH_QUERY);

    let response: SubgraphDeploymentsResponse = reqwest::Client::new()
    .post(NETWORK_SUBGRAPH_URL)
    .json(&map)
    .send()
    .await?
    .json()
    .await?;

    let mut wtr = csv::Writer::from_path(CSV_FILE_PATH)?;

    for subgraph_deployment in &response.data["subgraphDeployments"] {
        wtr.serialize(CsvRecord {
            id: &subgraph_deployment.id,
            activeSubgraphCount: &subgraph_deployment.activeSubgraphCount,
            createdAt: &subgraph_deployment.createdAt,
            ipfsHash: &subgraph_deployment.ipfsHash,
            subgraphCount: &subgraph_deployment.subgraphCount,
            stakedTokens: &subgraph_deployment.stakedTokens,
            signalledTokens: &subgraph_deployment.signalledTokens,
            originalName: &subgraph_deployment.originalName,
        })?;
    }

    wtr.flush()?;

    Ok(())
} 
```

<br>
<br>

The completed `src/main.rs` looks something like this

``` rust
use std::collections::HashMap;
use std::string::String;
use std::error::Error;
use serde::{Serialize, Deserialize};

const NETWORK_SUBGRAPH_URL: &str = "https://api.thegraph.com/subgraphs/name/graphprotocol/graph-network-mainnet";
const NETWORK_SUBGRAPH_QUERY: &str = "{subgraphDeployments(where: {network: \"gnosis\"}) {id activeSubgraphCount createdAt ipfsHash subgraphCount stakedTokens signalledTokens originalName}}";
const CSV_FILE_PATH: &str = "./gnosis_subgraphs.csv";

#[allow(non_snake_case)]
#[derive(Debug, Serialize)]
struct CsvRecord<'a> {
    id: &'a String,
    activeSubgraphCount: &'a i32,
    createdAt: &'a i32,
    ipfsHash: &'a String,
    subgraphCount: &'a i32,
    stakedTokens: &'a String,
    signalledTokens: &'a String,
    originalName: &'a Option<String>,
}

#[derive(Debug, Deserialize, PartialEq)]
struct SubgraphDeploymentsResponse {
    data: HashMap<String, Vec<SubgraphDeployment>>
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, PartialEq)]
struct SubgraphDeployment {
    id: String,
    activeSubgraphCount: i32,
    createdAt: i32,
    ipfsHash: String,
    subgraphCount: i32,
    stakedTokens: String,
    signalledTokens: String,
    originalName: Option<String>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let mut map = HashMap::new();
    map.insert("query", NETWORK_SUBGRAPH_QUERY);

    let response: SubgraphDeploymentsResponse = reqwest::Client::new()
    .post(NETWORK_SUBGRAPH_URL)
    .json(&map)
    .send()
    .await?
    .json()
    .await?;

    let mut wtr = csv::Writer::from_path(CSV_FILE_PATH)?;

    for subgraph_deployment in &response.data["subgraphDeployments"] {
        wtr.serialize(CsvRecord {
            id: &subgraph_deployment.id,
            activeSubgraphCount: &subgraph_deployment.activeSubgraphCount,
            createdAt: &subgraph_deployment.createdAt,
            ipfsHash: &subgraph_deployment.ipfsHash,
            subgraphCount: &subgraph_deployment.subgraphCount,
            stakedTokens: &subgraph_deployment.stakedTokens,
            signalledTokens: &subgraph_deployment.signalledTokens,
            originalName: &subgraph_deployment.originalName,
        })?;
    }

    wtr.flush()?;

    Ok(())
} 

```

<br>
<br>

Save your changes then run the program from the integrated terminal in VSCode

``` bash
cargo run
```

<br>
<br>

Open `gnosis_subgraphs.csv` to inspect the results
