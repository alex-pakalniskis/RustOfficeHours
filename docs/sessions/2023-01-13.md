# Deserialize subgraph manifest YAML

*ROH: 2023-01-13*

#### Introduction

<br>

> The subgraph manifest `subgraph.yaml` defines the smart contracts your subgraph indexes, which events from these contracts to pay attention to, and how to map event data to entities that Graph Node stores and allows to query.
> 
> -[The Graph Official Docs](https://thegraph.com/docs/en/developing/creating-a-subgraph/#the-subgraph-manifest)

<br>
<br>

In this lesson we're building a program to deserialize a subgraph manifest stored on [IPFS](https://en.wikipedia.org/wiki/InterPlanetary_File_System) 
* The Graph Hosted service endpoint: [`graph-network-mainnet` subgraph](https://api.thegraph.com/subgraphs/name/graphprotocol/graph-network-mainnet)
* IPFS URL: https://ipfs.io/ipfs/QmbW34MGRyp7LWkpDyKXDLWsKrN8iqZrNAMjGTYHN2zHa1


<br>
<br>

> **Deserialization**: The process whereby a lower-level format (e.g. that has been transferred over a network, or stored in a data store) is translated into a readable object or other data structure.
> 
> -[MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/Deserialization)


<br>

Along with previously covered Rust concepts (see other guides), here’s a quick overview of the topics we’ll encouter in this lesson
* define custom `structs` that represent the generic properties of a subgraph manifest
* leverage [`serde_yaml`](https://docs.rs/serde_yaml/latest/serde_yaml/) crate and [`serde`](https://docs.rs/serde/latest/serde/) crate's `derive` macro to deserialize the subgraph manifest `YAML` into custom `structs`.
* validate a program with a basic [test](https://docs.rs/tokio/0.2.3/tokio/attr.test.html)

<br>

Let's get started!

<br>

#### Code

<br>

From your terminal/command line, create a new `cargo` project and open it with VSCode
* If you don't already have Rust and `cargo` installed, here's the [official installation guide](https://doc.rust-lang.org/cargo/getting-started/installation.html) to help you get up and running. 
* This tutorial assumes you are using [Visual Studio Code](https://code.visualstudio.com/download) editor (VSCode).


``` bash
cargo new parse_subgraph_manifest
cd parse_subgraph_manifest
code .
```
<br>
<br>

With VSCode now open, update Cargo.toml with the following dependencies (add this below [dependencies]) then save your changes

``` toml
reqwest = { version = "0.11.13", features = ["json"] }
tokio = { version = "1.23.0", features = ["full"] }
serde = { version = "1.0.152",  features = ["derive"]}
serde_yaml = "0.9.16"
```

<br>

* [`reqwest`](https://docs.rs/reqwest/latest/reqwest/) "provides a convenient, higher-level HTTP Client"
* [`tokio`](https://docs.rs/tokio/latest/tokio/) is an "event-driven, non-blocking I/O platform for writing asynchronous applications with the Rust programming language"
* [`serde`](https://docs.rs/serde/latest/serde/) is a "framework for serializing and deserializing Rust data structures efficiently and generically"
* [`serde_yaml`](https://docs.rs/serde_yaml/latest/serde_yaml/) is a library for using the Serde serialization framework with data in YAML file format.


<br>
<br>

Create a new file called src/utils.rs and add these `use` statements

``` rust
use std::collections::HashMap;
use std::string::String;
use serde::Deserialize;
```
<br>
<br>

Next, add some `struct` statments to the same file the save

``` rust
#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct SubgraphManifest {
    pub dataSources: Vec<DataSource>,
    pub description: String,
    pub repository: String,
    pub specVersion: String,
    pub schema: SchemaAddress,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct SchemaAddress {
    pub file: HashMap<String, String>,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct DataSource {
    pub kind: String,
    pub mapping: Mapping,
    pub name: String,
    pub network: String,
    pub source: Source,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct Mapping {
    pub abis: serde_yaml::Sequence,
    pub apiVersion: String,
    pub entities: serde_yaml::Sequence,
    pub eventHandlers: serde_yaml::Sequence,
    pub file: HashMap<String, String>,
    pub kind: String,
    pub language: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct Source {
    pub abi: String,
    pub address: String,
    pub startBlock: u32,
}
```
<br>
<br>

Navigate to src/main.rs and add the following `use` and `mod` statements

``` rust
use std::error::Error;

mod utils;
use crate::utils::SubgraphManifest;
```

<br>
<br>

Now add a `main` function

``` rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {

    let manifest_response = reqwest::get("https://ipfs.io/ipfs/QmbW34MGRyp7LWkpDyKXDLWsKrN8iqZrNAMjGTYHN2zHa1")
    .await?
    .text()
    .await?;

    let manifest_data: SubgraphManifest = serde_yaml::from_str(&manifest_response).unwrap();

    println!("{:?}", manifest_data);

    Ok(())
}
```

<br>
<br>

Save your changes then run the program from the integrated terminal in VSCode

``` bash
cargo run
```

<br>
<br>


Let's add a test below the `main` function 

``` rust
#[tokio::test]
async fn deserialize_everest_subgraph_manifest_repo()-> Result<(), Box<dyn Error>> {
    let manifest_response = reqwest::get("https://ipfs.io/ipfs/QmVsp1bC9rS3rf861cXgyvsqkpdsTXKSnS4729boXZvZyH")
    .await?
    .text()
    .await?;

    let manifest_data: SubgraphManifest = serde_yaml::from_str(&manifest_response).unwrap();

    let subgraph_manifest_repository = "https://github.com/graphprotocol/everest";

    assert_eq!(manifest_data.repository, subgraph_manifest_repository);

    Ok(())
}
```

<br>
<br>


Run your test

``` bash
cargo test
```



